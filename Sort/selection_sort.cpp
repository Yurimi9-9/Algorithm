// 정렬 - 선택 정렬
void selectionSort(int a[], int n)
{
	for(int i=0; i<n-1; i++)
	{
		int index = i;			// index=0인 경우, 에러 (아래에서 설명)
		for(int j=i; j<n; j++)
			if(a[j] < a[index])	// 1
				index = j;		// 2
		//
		int temp = a[index];	// 3 (아래 2줄 포함, 3줄)
		a[index] = a[i];		//
		a[i] = temp;			//
	}
}
// 시간 복잡도 = O(n²)
// (원소 비교 횟수)

/*
 *  [ index=0인 경우, 에러가 나는 이유 ]
 *
 *  가장 바깥의 for문에서 매 루프마다 index=0으로 초기화한다면
 *  1)	if(a[j] < a[index]) 비교에서 a[j]와
 *  	a[index] == a[0](가장 작은 원소)를  비교하게 되고
 *
 *  2)	if문 속의 조건문이 항상 거짓이 되므로
 *  	index 값은 0으로 고정되어 변할 수 없게 된다.
 *
 *  3)	이 상태에서 a[0]과 a[i]의 원소 값을 교환하게 되고,
 *  	최솟값이었던 a[0]의 원소는 교환 후 더이상 최솟값이 아니게 된다!
 *
 *  +)	두 번째 roop이후로는 a[index]==a[0] 값이 최소가 아니므로
 *  	2)에서 발생하는 문제는 해결되지만
 *  	a[0]의 원소에 최솟값이 들어가지 못하고 a[1]부터 순서대로 정렬이 되므로
 *
 *  	최종 정렬의 결과는 (위의 코드에서 index=i를 index=0으로 변경했을 경우)
 *  	a[0] - a[1] - a[2] - a[3] - ... - a[n-1]
 *     (최댓값)  (최댓값을 제외한 나머지 값들 순서대로 정렬) 이다.
 *
 *		결과의 이유
 *		 : a[0]의 위치에 배열 원소의 최댓값이 들어가면, 빠져나올 수 없기 때문!
 */
